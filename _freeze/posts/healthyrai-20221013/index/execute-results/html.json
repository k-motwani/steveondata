{
  "hash": "00d42138ea946a4113a99ae0ac6e7bfa",
  "result": {
    "markdown": "---\ntitle: \"healthyR.ai Primer\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2022-10-13\"\ncategories: [code, weeklytip, healthyrai]\nimage: healthyrai_logo.png\n---\n\n\nThis is going to serve as a sort of primer for my r packge `{healthyR.ai}`. The goal of this package is to help with producing uniform `machine learning`/`ai` models either from scratch or by way of one of the `boilerplate` functions.\n\nThis particular article is going to focus on `k-means` clustering with `umap` projection and visualization.\n\nFirst things first, lets load in the library:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(healthyR.ai)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\n== Welcome to healthyR.ai ===========================================================================\nIf you find this package useful, please leave a star: \n   https://github.com/spsanderson/healthyR.ai'\n\nIf you encounter a bug or want to request an enhancement please file an issue at:\n   https://github.com/spsanderson/healthyR.ai/issues\n\nThank you for using healthyR.ai\n```\n:::\n:::\n\n\n# Information\n\nK-Means is a partition algorithm initially designed for signal processing.\nThe goal is to partition *`n`* observations into *`k`* clusters where\neach *`n`* is in *`k`*. The unsupervised k-means algorithm has a loose\nrelationship to the k-nearest neighbor classifier, a popular supervised\nmachine learning technique for classification that is often confused\nwith k-means due to the name. Applying the 1-nearest neighbor classifier\nto the cluster centers obtained by k-means classifies new data into the\nexisting clusters.\n\nThe aim of this post is to showcase the use of the `healthyR.ai`\nwrapper for the `kmeans` function along with the wrapper and plot for the\n`uwot::umap` projection function. We will go through the entire workflow\nfrom getting the data to getting the final `UMAP` plot.\n\n# Generate some data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages(library(healthyR.data))\nsuppressPackageStartupMessages(library(dplyr))\nsuppressPackageStartupMessages(library(broom))\nsuppressPackageStartupMessages(library(ggplot2))\n\ndata_tbl <- healthyR_data %>%\n    filter(ip_op_flag == \"I\") %>%\n    filter(payer_grouping != \"Medicare B\") %>%\n    filter(payer_grouping != \"?\") %>%\n    select(service_line, payer_grouping) %>%\n    mutate(record = 1) %>%\n    as_tibble()\n\ndata_tbl %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 116,823\nColumns: 3\n$ service_line   <chr> \"Medical\", \"Schizophrenia\", \"Syncope\", \"Pneumonia\", \"Ch…\n$ payer_grouping <chr> \"Blue Cross\", \"Medicare A\", \"Medicare A\", \"Medicare A\",…\n$ record         <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n```\n:::\n:::\n\n\nNow that we have our data we need to generate what is called a user item\ntable. To do this we use the function *`hai_kmeans_user_item_tbl`* which\ntakes in just a few arguments. The purpose of the user item table is to\naggregate and normalize the data between the users and the items.\n\nThe data that we have generated is going to look for clustering amongst\nthe *`service_lines`* (the user) and the *`payer_grouping`* (item)\ncolumns.\n\nLets now create the user item table.\n\n# User Item Tibble\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuit_tbl <- hai_kmeans_user_item_tbl(\n  data_tbl, \n  service_line, \n  payer_grouping, \n  record\n)\n\nuit_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23 × 12\n   service_line   Blue …¹ Comme…² Compe…³ Excha…⁴    HMO Medic…⁵ Medic…⁶ Medic…⁷\n   <chr>            <dbl>   <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl>   <dbl>\n 1 Alcohol Abuse   0.0941 0.0321  5.25e-4 0.0116  0.0788 0.158    0.367   0.173 \n 2 Bariatric Sur…  0.317  0.0583  0       0.0518  0.168  0.00324  0.343   0.0485\n 3 Carotid Endar…  0.0845 0.0282  0       0       0.0141 0        0.0282  0.648 \n 4 Cellulitis      0.110  0.0339  1.18e-2 0.00847 0.0805 0.0869   0.192   0.355 \n 5 Chest Pain      0.144  0.0391  2.90e-3 0.00543 0.112  0.0522   0.159   0.324 \n 6 CHF             0.0295 0.00958 5.18e-4 0.00414 0.0205 0.0197   0.0596  0.657 \n 7 COPD            0.0493 0.0228  2.28e-4 0.00548 0.0342 0.0461   0.172   0.520 \n 8 CVA             0.0647 0.0246  1.07e-3 0.0107  0.0524 0.0289   0.0764  0.555 \n 9 GI Hemorrhage   0.0542 0.0175  1.25e-3 0.00834 0.0480 0.0350   0.0855  0.588 \n10 Joint Replace…  0.139  0.0179  3.36e-2 0.00673 0.0516 0        0.0874  0.5   \n# … with 13 more rows, 3 more variables: `Medicare HMO` <dbl>,\n#   `No Fault` <dbl>, `Self Pay` <dbl>, and abbreviated variable names\n#   ¹​`Blue Cross`, ²​Commercial, ³​Compensation, ⁴​`Exchange Plans`, ⁵​Medicaid,\n#   ⁶​`Medicaid HMO`, ⁷​`Medicare A`\n```\n:::\n:::\n\n\nThe table is aggregated by item for the various users to which the\nalgorithm will be applied.\n\nNow that we have this data we need to find what will be out optimal k\n(clusters). To do this we need to generate a table of data that will\nhave a column of k and for that k apply the k-means function to the data\nwith that k and return the **`total within sum of squares`**.\n\nTo do this there is a convienent function called *`hai_kmeans_mapped_tbl`*\nthat takes as its sole argument the output from the\n*`hai_kmeans_user_item_tbl`*. There is an argument *`.centers`* where the\ndefault is set to 15.\n\n# K-Means Mapped Tibble\n\n::: {.cell}\n\n```{.r .cell-code}\nkmm_tbl <- hai_kmeans_mapped_tbl(uit_tbl)\nkmm_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 15 × 3\n   centers k_means  glance          \n     <int> <list>   <list>          \n 1       1 <kmeans> <tibble [1 × 4]>\n 2       2 <kmeans> <tibble [1 × 4]>\n 3       3 <kmeans> <tibble [1 × 4]>\n 4       4 <kmeans> <tibble [1 × 4]>\n 5       5 <kmeans> <tibble [1 × 4]>\n 6       6 <kmeans> <tibble [1 × 4]>\n 7       7 <kmeans> <tibble [1 × 4]>\n 8       8 <kmeans> <tibble [1 × 4]>\n 9       9 <kmeans> <tibble [1 × 4]>\n10      10 <kmeans> <tibble [1 × 4]>\n11      11 <kmeans> <tibble [1 × 4]>\n12      12 <kmeans> <tibble [1 × 4]>\n13      13 <kmeans> <tibble [1 × 4]>\n14      14 <kmeans> <tibble [1 × 4]>\n15      15 <kmeans> <tibble [1 × 4]>\n```\n:::\n:::\n\n\nAs we see there are three columns, `centers`, `k_means` and `glance`.\nThe k_means column is the `k_means` list object and `glance` is the\ntibble returned by the `broom::glance` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkmm_tbl %>%\n  tidyr::unnest(glance)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 15 × 6\n   centers k_means  totss tot.withinss betweenss  iter\n     <int> <list>   <dbl>        <dbl>     <dbl> <int>\n 1       1 <kmeans>  1.41       1.41    1.33e-15     1\n 2       2 <kmeans>  1.41       0.592   8.17e- 1     1\n 3       3 <kmeans>  1.41       0.372   1.04e+ 0     2\n 4       4 <kmeans>  1.41       0.276   1.13e+ 0     2\n 5       5 <kmeans>  1.41       0.202   1.21e+ 0     2\n 6       6 <kmeans>  1.41       0.159   1.25e+ 0     3\n 7       7 <kmeans>  1.41       0.124   1.28e+ 0     3\n 8       8 <kmeans>  1.41       0.0884  1.32e+ 0     2\n 9       9 <kmeans>  1.41       0.0745  1.33e+ 0     3\n10      10 <kmeans>  1.41       0.0576  1.35e+ 0     2\n11      11 <kmeans>  1.41       0.0460  1.36e+ 0     2\n12      12 <kmeans>  1.41       0.0363  1.37e+ 0     3\n13      13 <kmeans>  1.41       0.0293  1.38e+ 0     3\n14      14 <kmeans>  1.41       0.0202  1.39e+ 0     2\n15      15 <kmeans>  1.41       0.0161  1.39e+ 0     2\n```\n:::\n:::\n\n\nAs stated we use the `tot.withinss` to decide what will become our *`k`*, an easy way to do this is to visualize the Scree Plot, also known as the elbow plot. This is done by ploting the `x-axis` as the `centers` and the `y-axis` as the `tot.withinss`.\n\n# Scree Plot and Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhai_kmeans_scree_plt(.data = kmm_tbl)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scree_plt-1.png){width=672}\n:::\n:::\n\n\nIf we want to see the scree plot data that creates the plot then we can use another function `hai_kmeans_scree_data_tbl`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhai_kmeans_scree_data_tbl(kmm_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 15 × 2\n   centers tot.withinss\n     <int>        <dbl>\n 1       1       1.41  \n 2       2       0.592 \n 3       3       0.372 \n 4       4       0.276 \n 5       5       0.202 \n 6       6       0.159 \n 7       7       0.124 \n 8       8       0.0884\n 9       9       0.0745\n10      10       0.0576\n11      11       0.0460\n12      12       0.0363\n13      13       0.0293\n14      14       0.0202\n15      15       0.0161\n```\n:::\n:::\n\n\nWith the above pieces of information we can decide upon a value for *`k`*, in this instance we are going to use 3. Now that we have that we can go ahead with creating the umap list object where we can take a look at a great many things associated with the data.\n\n# UMAP List Object\n\nNow lets go ahead and create our UMAP list object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nump_lst <- hai_umap_list(.data = uit_tbl, kmm_tbl, 3)\n```\n:::\n\n\nNow that it is created, lets take a look at each item in the list. The `umap_list` function returns a list of 5 items.\n\n  * umap_obj\n  * umap_results_tbl\n  * kmeans_obj\n  * kmeans_cluster_tbl\n  * umap_kmeans_cluster_results_tbl\n  \nSince we have the list object we can now inspect the `kmeans_obj`, first thing we will do is use the `hai_kmeans_tidy_tbl` function to inspect things.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkm_obj <- ump_lst$kmeans_obj\nhai_kmeans_tidy_tbl(.kmeans_obj = km_obj, .data = uit_tbl, .tidy_type = \"glance\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n  totss tot.withinss betweenss  iter\n  <dbl>        <dbl>     <dbl> <int>\n1  1.41        0.372      1.04     2\n```\n:::\n\n```{.r .cell-code}\nhai_kmeans_tidy_tbl(km_obj, uit_tbl, \"augment\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23 × 2\n   service_line                  cluster\n   <chr>                         <fct>  \n 1 Alcohol Abuse                 1      \n 2 Bariatric Surgery For Obesity 1      \n 3 Carotid Endarterectomy        2      \n 4 Cellulitis                    3      \n 5 Chest Pain                    3      \n 6 CHF                           2      \n 7 COPD                          2      \n 8 CVA                           2      \n 9 GI Hemorrhage                 2      \n10 Joint Replacement             2      \n# … with 13 more rows\n```\n:::\n\n```{.r .cell-code}\nhai_kmeans_tidy_tbl(km_obj, uit_tbl, \"tidy\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 14\n  Blue …¹ Comme…² Compe…³ Excha…⁴    HMO Medic…⁵ Medic…⁶ Medic…⁷ Medic…⁸ No Fa…⁹\n    <dbl>   <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1  0.150   0.0368 3.07e-4 0.0207  0.163   0.131   0.314    0.132  0.0319 0.00136\n2  0.0784  0.0218 4.32e-3 0.00620 0.0449  0.0368  0.0800   0.563  0.152  0.00348\n3  0.117   0.0314 1.02e-2 0.0139  0.0982  0.0856  0.147    0.354  0.105  0.00707\n# … with 4 more variables: `Self Pay` <dbl>, size <int>, withinss <dbl>,\n#   cluster <fct>, and abbreviated variable names ¹​`Blue Cross`, ²​Commercial,\n#   ³​Compensation, ⁴​`Exchange Plans`, ⁵​Medicaid, ⁶​`Medicaid HMO`,\n#   ⁷​`Medicare A`, ⁸​`Medicare HMO`, ⁹​`No Fault`\n```\n:::\n:::\n\n\n# UMAP Plot\n\nNow that we have all of the above data we can visualize our clusters that are colored by their cluster number.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhai_umap_plot(.data = ump_lst, .point_size = 3, TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/umap_plt-1.png){width=672}\n:::\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}