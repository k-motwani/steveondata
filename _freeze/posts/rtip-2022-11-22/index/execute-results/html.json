{
  "hash": "f2241d1c10487f7910ea79f99873da55",
  "result": {
    "markdown": "---\ntitle: \"Data Preprocessing Scale/Normalize with {healthyR.ai}\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2022-11-22\"\ncategories: [code, rtip, healthyrai, recipes]\n---\n\n\n# Introduction\n\nA large portion of data modeling occurrs not only in the data cleaning phase but also in the _data preprocessing_ phase. This can include things like _scaling_ or _normalizing_ data before proceeding to the modeling phase. I will discuss one such function from my _r package_ [`{healthyR.ai}`](https://www.spsanderson.com/healthyR.ai/). In this post I will go over [`hai_data_scale()`](https://www.spsanderson.com/healthyR.ai/reference/hai_data_scale.html)\n\nThis is a `{recipes}` style `step` function and is `tidymodels` compliant.\n\n# Function\n\nLet's take a look at the function call.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhai_data_scale(\n  .recipe_object = NULL,\n  ...,\n  .type_of_scale = \"center\",\n  .range_min = 0,\n  .range_max = 1,\n  .scale_factor = 1\n)\n```\n:::\n\n\nNow let's go over the arguments that get supplied to the parameters of this function.\n\n*  `.recipe_object` - The data that you want to process\n*  `...` -  One or more selector functions to choose variables to be imputed. When used with imp_vars, these dots indicate which variables are used to predict the missing data in each variable. See selections() for more details\n*  `.type_of_scale` - This is a quoted argument and can be one of the following:\n    1. \"center\"\n    2. \"normalize\"\n    3. \"range\"\n    4. \"scale\"\n*  `range_min` - A single numeric value for the smallest value in the range. This defaults to 0.\n*  `.range_max` - A single numeric value for the largeest value in the range. This defaults to 1.\n*  `.scale_factor` - A numeric value of either 1 or 2 that scales the numeric inputs by one or two standard deviations. By dividing by two standard deviations, the coefficients attached to continuous predictors can be interpreted the same way as with binary inputs. Defaults to 1.\n\n# Example\n\nNow let's see it in action!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(healthyR.ai)\nlibrary(dplyr)\nlibrary(recipes)\n\ndate_seq <- seq.Date(\n  from = as.Date(\"2013-01-01\"), \n  length.out = 100, \n  by = \"month\"\n)\n\nval_seq <- rep(rnorm(10, mean = 6, sd = 2), times = 10)\n\ndf_tbl <- tibble(\n  date_col = date_seq,\n  value    = val_seq\n)\n\ndf_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100 × 2\n   date_col   value\n   <date>     <dbl>\n 1 2013-01-01  6.66\n 2 2013-02-01  6.66\n 3 2013-03-01  5.09\n 4 2013-04-01  6.94\n 5 2013-05-01  5.96\n 6 2013-06-01  6.18\n 7 2013-07-01  3.62\n 8 2013-08-01  7.31\n 9 2013-09-01  4.58\n10 2013-10-01  7.29\n# … with 90 more rows\n```\n:::\n\n```{.r .cell-code}\nrec_obj <- recipe(value ~ ., df_tbl)\n\nnew_rec_obj <- hai_data_scale(\n  .recipe_object = rec_obj,\n  value,\n  .type_of_scale = \"center\"\n)$scale_rec_obj\n\nnew_rec_obj %>% \n  get_juiced_data()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100 × 2\n   date_col     value\n   <date>       <dbl>\n 1 2013-01-01  0.633 \n 2 2013-02-01  0.630 \n 3 2013-03-01 -0.935 \n 4 2013-04-01  0.909 \n 5 2013-05-01 -0.0676\n 6 2013-06-01  0.149 \n 7 2013-07-01 -2.41  \n 8 2013-08-01  1.28  \n 9 2013-09-01 -1.45  \n10 2013-10-01  1.26  \n# … with 90 more rows\n```\n:::\n:::\n\n\nVoila!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}