{
  "hash": "3cebffbcf0114848ca5cba7bf0ec9661",
  "result": {
    "markdown": "---\ntitle: \"Z-Score Scaling Step Recipe with {healthyR.ai}\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2022-12-06\"\ncategories: [code, rtip, healthyrai, recipes]\n---\n\n\n# Introduction\n\nSometimes one may find it useful or necessary to scale their data during a modeling or analysis phase. One of these such transformations is the z-score scaling.\n\nThis is done simply by performing the below transform where x is simply some numeric vector:\n\n$$ z_x = (x - mu(x))/sd(x) $$\n\nLet's take a look at the `recipe` function called [`step_hai_scale_zscore`](https://www.spsanderson.com/healthyR.ai/reference/step_hai_scale_zscore.html)\n\n# Function\n\nHere is the full function call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep_hai_scale_zscore(\n  recipe,\n  ...,\n  role = \"predictor\",\n  trained = FALSE,\n  columns = NULL,\n  skip = FALSE,\n  id = rand_id(\"hai_scale_zscore\")\n)\n```\n:::\n\n\nHere are the arguments to the function.\n\n*  `recipe` - A recipe object. The step will be added to the sequence of operations for this recipe.\n*  `...` - One or more selector functions to choose which variables that will be used to create the new variables. The selected variables should have class numeric\n*  `role` - For model terms created by this step, what analysis role should they be assigned?. By default, the function assumes that the new variable columns created by the original variables will be used as predictors in a model.\n*  `trained` - A logical to indicate if the quantities for preprocessing have been estimated.\n*  `columns` - A character string of variables that will be used as inputs. This field is a placeholder and will be populated once recipes::prep() is used.\n*  `skip` - A logical. Should the step be skipped when the recipe is baked by bake.recipe()? While all operations are baked when prep.recipe() is run, some operations may not be able to be conducted on new data (e.g. processing the outcome variable(s)). Care should be taken when using skip = TRUE as it may affect the computations for subsequent operations.\n*  `id` - A character string that is unique to this step to identify it.\n\n# Example\n\nHere is a simple example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(healthyR.ai)\nlibrary(dplyr)\nlibrary(recipes)\n\ndf <- iris |>\n  as_tibble() |>\n  select(Species, Sepal.Length)\n\nrec_obj <- recipe(Sepal.Length ~ ., data = df) %>%\n  step_hai_scale_zscore(Sepal.Length)\n\nrec_obj\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRecipe\n\nInputs:\n\n      role #variables\n   outcome          1\n predictor          1\n\nOperations:\n\nZero-One Scale Transformation on Sepal.Length\n```\n:::\n\n```{.r .cell-code}\nsummary(rec_obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 Ã— 4\n  variable     type      role      source  \n  <chr>        <list>    <chr>     <chr>   \n1 Species      <chr [3]> predictor original\n2 Sepal.Length <chr [2]> outcome   original\n```\n:::\n:::\n\n\nNow let's take a look at the differences.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(plotly)\n\ndf_tbl <- get_juiced_data(rec_obj)\n\ndf_tbl |>\n  purrr::set_names(\"Species\",\"Sepal_Length\",\"Scaled_Sepal_Length\") |>\n  ggplot(aes(x = Sepal_Length)) +\n  geom_histogram(color = \"black\", fill = \"lightgreen\") +\n  geom_histogram(aes(x = Scaled_Sepal_Length), \n                 color = \"black\", fill = \"steelblue\") +\n  theme_minimal() +\n  labs(\n    y = \"Count\",\n    x = \"Sepal Length\",\n    title = \"Speal.Length: Original vs. Z-Score Scaled\",\n    subtitle = \"Original (Light Green) Scaled (Steelblue)\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/example2-1.png){width=672}\n:::\n:::\n\n\nVoila!",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}