{
  "hash": "472543ce7e7dc5ae7b2e3de09736d2cc",
  "result": {
    "markdown": "---\ntitle: \"Create Multiple {parsnip} Model Specs with {purrr}\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2022-12-07\"\ncategories: [code, rtip, parsnip, purrr]\n---\n\n\n# Introduction\n\nIf you want to generate multiple `parsnip` model specifications at the same time then it's really not to hard. This sort of thing is being addressed in an upcoming package of mine called [`{tidyaml}`](https://www.spsanderson.com/tidyaml)\n\nThis post is going to be quick and simple, I will showcase how you can generate many different model specifications in one go. I will also discuss the function [`create_model_spec()`](https://www.spsanderson.com/tidyaml/reference/create_model_spec.html) that will allow you to do this with a simple function call once the package is actually released.\n\n# Function\n\nHere is the function call for the `create_model_spec()` for once it is release.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_model_spec(\n  .parsnip_eng = list(\"lm\"),\n  .mode = list(\"regression\"),\n  .parsnip_fns = list(\"linear_reg\"),\n  .return_tibble = TRUE\n)\n```\n:::\n\n\nHere are the arguments to the function.\n*  `.parsnip_eng` - The input must be a list. The default for this is set to all. This means that all of the parsnip linear regression engines will be used, for example lm, or glm. You can also choose to pass a c() vector like c('lm', 'glm')\n*  `.mode`- The input must be a list. The default is 'regression'\n*  `.parsnip_fns` - The input must be a list. The default for this is set to all. This means that all of the parsnip linear regression functions will be used, for example linear_reg(), or cubist_rules. You can also choose to pass a c() vector like c(\"linear_reg\",\"cubist_rules\")\n*  `.return_tibble` - The default is TRUE. FALSE will return a list object.\n\n\n# Example\n\nHere is the function at work.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyaml)\n\ncreate_model_spec(\n .parsnip_eng = list(\"lm\",\"glm\",\"glmnet\",\"cubist\"),\n .parsnip_fns = list(\n      rep(\n        \"linear_reg\", 3),\n        \"cubist_rules\"\n     )\n )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 Ã— 4\n  .parsnip_engine .parsnip_mode .parsnip_fns .model_spec\n  <chr>           <chr>         <chr>        <list>     \n1 lm              regression    linear_reg   <spec[+]>  \n2 glm             regression    linear_reg   <spec[+]>  \n3 glmnet          regression    linear_reg   <spec[+]>  \n4 cubist          regression    cubist_rules <spec[+]>  \n```\n:::\n\n```{.r .cell-code}\ncreate_model_spec(\n .parsnip_eng = list(\"lm\",\"glm\",\"glmnet\",\"cubist\"),\n .parsnip_fns = list(\n      rep(\n        \"linear_reg\", 3),\n        \"cubist_rules\"\n     ),\n .return_tibble = FALSE\n )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$.parsnip_engine\n$.parsnip_engine[[1]]\n[1] \"lm\"\n\n$.parsnip_engine[[2]]\n[1] \"glm\"\n\n$.parsnip_engine[[3]]\n[1] \"glmnet\"\n\n$.parsnip_engine[[4]]\n[1] \"cubist\"\n\n\n$.parsnip_mode\n$.parsnip_mode[[1]]\n[1] \"regression\"\n\n\n$.parsnip_fns\n$.parsnip_fns[[1]]\n[1] \"linear_reg\"\n\n$.parsnip_fns[[2]]\n[1] \"linear_reg\"\n\n$.parsnip_fns[[3]]\n[1] \"linear_reg\"\n\n$.parsnip_fns[[4]]\n[1] \"cubist_rules\"\n\n\n$.model_spec\n$.model_spec[[1]]\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\n\n$.model_spec[[2]]\nLinear Regression Model Specification (regression)\n\nComputational engine: glm \n\n\n$.model_spec[[3]]\nLinear Regression Model Specification (regression)\n\nComputational engine: glmnet \n\n\n$.model_spec[[4]]\nCubist Model Specification (regression)\n\nComputational engine: cubist \n```\n:::\n:::\n\n\nNow that we have seen what is to come in the future, let's take a look at a pseudo solution that is easy to replicate now.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the purrr package\nlibrary(purrr)\nlibrary(parsnip)\n\n# Create a list of parsnip engines\nengines <- list(\n  engine1 = \"lm\",\n  engine2 = \"glm\",\n  engine3 = \"randomForest\"\n)\n\n# Create a list of parsnip call names\nparsnip_calls <- list(\n  call1 = \"linear_reg\",\n  call2 = \"linear_reg\",\n  call3 = \"rand_forest\"\n)\n\n# Use pmap() to create a list of parsnip model specs from the list of engines\n# and parsnip call names\n# Set the mode argument to \"regression\"\nmodel_specs <- pmap(list(engines, parsnip_calls), function(engine, call) {\n  match.fun(call)(engine = engine, mode = \"regression\")\n})\n\n# Print the list of model specs to the console\nmodel_specs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$engine1\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\n\n$engine2\nLinear Regression Model Specification (regression)\n\nComputational engine: glm \n\n\n$engine3\nRandom Forest Model Specification (regression)\n\nComputational engine: randomForest \n```\n:::\n:::\n\n\nVoila!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}