{
  "hash": "30d54a0d46b24495896ffe8c9cc1fd41",
  "result": {
    "markdown": "---\ntitle: \"Use of the apply family of functions\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2023-03-10\"\ncategories: [code, rtip, apply]\n---\n\n\n# Introduction\n\nIn this post I will talk about the use of the R functions `apply()`, `lapply()`, `sapply()`, `tapply()`, and `vapply()` with examples.\n\nThese functions are all designed to help users apply a function to a set of data in R, but they differ in their input and output types, as well as in the way they handle missing values and other complexities. By using the right function for your particular problem, you can make your code more efficient and easier to read.\n\nLet's start with the basics.\n\n## The Basics\n\nBefore we dive into the details of each function, let's define some terms:\n\n*  A vector is a one-dimensional array of data, like a list of numbers or strings.\n*  A matrix is a two-dimensional array of data, like a table of numbers.\n*  A data frame is a two-dimensional object that can hold different types of data, like a spreadsheet.\n*  A list is a collection of objects, which can be of different types, like a shopping bag full of different items.\n\nEach of the five functions we'll discuss here takes a list as input (although some can also take vectors or matrices). Let's create a list object to use in our examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(\n  a = c(1, 2, 3),\n  b = matrix(1:6, nrow = 2),\n  c = data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\")),\n  d = c(4, NA, 6),\n  e = list(\"foo\", \"bar\", \"baz\")\n)\n```\n:::\n\n\nThis list contains five elements:\n\n*    A vector of numbers (a)\n*    A matrix of numbers (b)\n*    A data frame with two columns (c)\n*    A vector of numbers with a missing value (d)\n*    A list of character strings (e)\n\nNow that we have our data, let's look at each of the functions in turn.\n\n## The Functions\n__apply()__\n\nThe `apply()` function applies a function to the rows or columns of a matrix or array. It is most commonly used with matrices, but can also be used with higher-dimensional arrays. The function takes three arguments:\n\n*    The matrix or array to apply the function to\n*    The margin (1 for rows, 2 for columns, or a vector of dimensions)\n*    The function to apply\n\nLet's apply the `mean()` function to the columns of our matrix in `my_list$b`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(my_list$b, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.5 3.5 5.5\n```\n:::\n:::\n\n\nThis will return a vector of means for each column of the matrix\n\n__lapply()__\n\nThe `lapply()` function applies a function to each element of a list and returns a list of the results. It takes two arguments:\n\n*    The list to apply the function to\n*    The function to apply\n\nLet's apply the `class()` function to each element of our list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(my_list, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] \"numeric\"\n\n$b\n[1] \"matrix\" \"array\" \n\n$c\n[1] \"data.frame\"\n\n$d\n[1] \"numeric\"\n\n$e\n[1] \"list\"\n```\n:::\n:::\n\n\nThis will return a list of the classes of each element.\n\n__sapply()__\n\nThe `sapply()` function is similar to `lapply()`, but it simplifies the output to a vector or matrix if possible. It takes the same two arguments as `lapply()`:\n\n*    The list to apply the function\n*    The function to apply\n\nLet's apply the `length()` function to each element of our list using sapply():\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(my_list, length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na b c d e \n3 6 2 3 3 \n```\n:::\n:::\n\n\nThis will return a vector of lengths for each element.\n\n__tapply()__\n\nThe `tapply()` function applies a function to subsets of a vector or data frame, grouped by one or more factors. It takes three arguments:\n\n*    The vector or data frame to apply the function to\n*    The factor(s) to group the data by\n*    The function to apply\n\nLet's apply the `mean()` function to the elements of our vector `my_list$d`, grouped by whether they are missing or not:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntapply(my_list$d, !is.na(my_list$d), mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFALSE  TRUE \n   NA     5 \n```\n:::\n:::\n\nThis will return a vector of means for each group where they are NOT NA.\n\n__vapply()__\n\nThe `vapply()` function is similar to sapply(), but allows the user to specify the output type and length, making it more efficient and less prone to errors. It takes four arguments:\n\n*    The list to apply the function to\n*    The function to apply\n*    The output type of the function\n*    The length of the output vector or matrix\n\nLet's apply the `length()` function to each element of our list, specifying that the output type is an integer and the length is 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(my_list, length, integer(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na b c d e \n3 6 2 3 3 \n```\n:::\n:::\n\nThis will return a matrix of lengths for each element, with 1 row:\n\n# Conclusion\n\nIn this blog post, we have covered the basics of the `apply()`, `lapply()`, `sapply()`, `tapply()`, and `vapply()` functions in R. These functions are all useful for applying a function to a set of data in R, but they differ in their input and output types, as well as in the way they handle missing values and other complexities. By using the right function for your particular problem, you can make your code more efficient and easier to read.\n\nVoila!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}