{
  "hash": "ff30dba85eba542f872fe8b6d19231c0",
  "result": {
    "markdown": "---\ntitle: \"Exploring Distributions with {shiny} and {TidyDensity} Part 4\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2023-04-21\"\ncategories: [rtip, shiny, tidydensity]\n---\n\n\n# Introduction\n\nIf you're new to data science or statistics, you may have heard about probability distributions. Probability distributions are mathematical functions that help us understand the probability of a random variable taking on a certain value. For example, if we're rolling a fair six-sided die, we know that each number has an equal chance of being rolled (1/6 or about 17% chance). We can represent this using a probability distribution, specifically a discrete uniform distribution.\n\nHowever, not all probability distributions are as simple as a uniform distribution. Many real-world phenomena, such as the heights of people, the number of cars passing through a toll booth in a day, or the amount of rainfall in a particular area, are continuous and can't be represented using a discrete distribution. Instead, we use continuous probability distributions, which describe the probability of a continuous variable taking on a range of values.\n\nThere are many different types of continuous probability distributions, each with their own properties and use cases. For example, the normal distribution, also known as the bell curve, is commonly used to model many natural phenomena, such as human heights and weights. The beta distribution is used to model proportions or percentages, such as the proportion of voters who support a particular candidate. The gamma distribution is used to model the time between events in a Poisson process, such as the time between customers arriving at a store.\n\nThe sample `TidyDensity App` is a tool that helps us explore and visualize these different types of probability distributions. It's a web application built using the R programming language and the Shiny framework, which allows us to create interactive web applications with R.\n\nLet's break down the different components of the TidyDensity App.\n\n# User Interface\n\nThe user interface, or UI for short, is what the user sees and interacts with when they use the app. It's built using HTML, CSS, and JavaScript, and it's the first thing the user sees when they open the app.\n\nThe TidyDensity App has a simple UI that allows the user to select from four different probability distributions: normal, Bernoulli, beta, and gamma. Each of these distributions has its own properties and use cases, and the user can select which one they want to explore using a dropdown menu.\n\nIn addition, the user can specify the number of simulations they want to run, which determines how many times the probability distribution is sampled to generate data. They can also specify the sample size, which determines how many data points are generated in each simulation.\n\nFinally, the user can select which type of plot they want to see, such as a density plot, a quantile plot, a probability plot, or a QQ plot. Each of these plots shows a different aspect of the data generated from the probability distribution, and the user can choose which one to explore.\n\nHere is the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(TidyDensity)\nlibrary(tidyverse)\nlibrary(DT)\n\n# Define UI\nui <- fluidPage(\n  titlePanel(\"TidyDensity App\"),\n  sidebarLayout(\n    sidebarPanel(\n      radioButtons(inputId = \"data_input_type\",\n                   label = \"Data Input Type:\",\n                   choices = c(\"Select Function\", \"Enter Data\"),\n                   selected = \"Select Function\"),\n      conditionalPanel(\n        condition = \"input.data_input_type == 'Enter Data'\",\n        textInput(inputId = \"data\",\n                  label = \"Enter data as a comma-separated list of numeric values\")\n      ),\n      conditionalPanel(\n        condition = \"input.data_input_type == 'Select Function'\",\n        selectInput(inputId = \"functions\",\n                    label = \"Select Function\",\n                    choices = c(\n                      \"tidy_normal\", \n                      \"tidy_bernoulli\", \n                      \"tidy_beta\", \n                      \"tidy_gamma\"\n                    )\n        )\n      ),\n      numericInput(inputId = \"num_sims\",\n                   label = \"Number of simulations:\",\n                   value = 1,\n                   min = 1,\n                   max = 15),\n      numericInput(inputId = \"n\",\n                   label = \"Sample size:\",\n                   value = 50,\n                   min = 30,\n                   max = 200),\n      selectInput(inputId = \"plot_type\",\n                  label = \"Select plot type\",\n                  choices = c(\n                    \"density\",\n                    \"quantile\",\n                    \"probability\",\n                    \"qq\",\n                    \"mcmc\"\n                  )\n      ),\n      downloadButton(outputId = \"download_data\", label = \"Download Data\")\n    ),\n    mainPanel(\n      plotOutput(\"density_plot\"),\n      DT::dataTableOutput(\"data_table\")\n    )\n  )\n)\n```\n:::\n\n\n![Here is the new addition to the UI](InputData.PNG)\n\n# Server\n\nThe server is the back-end of the `TidyDensity App`. It's responsible for generating the data based on the user's inputs, and for creating the plots and tables that the user sees on the UI.\n\nThe server is written in R, and it uses several R packages to generate the data and create the plots. For example, the `TidyDensity` package is used to generate data from the selected probability distribution, and the `ggplot2` package is used to create the plots.\n\nThe server is also responsible for handling user inputs, such as which probability distribution to use, how many simulations to run, and which plot type to show. It then generates the appropriate data and plot based on these inputs and sends them back to the UI for display.\n\nThe first thing we do is create a reactive variable data that will store the output of the `match.fun()` function, which is called with the arguments `.num_sims` and `.n` obtained from the user interface. We use the reactive variable because it will update automatically whenever the inputs are changed.\n\nThe `output$density_plot` object is created with `renderPlot()`, which takes the reactive variable `data(`) and passes it to `tidy_autoplot()` with the plot type selected by the user in the input$plot_type object. The resulting plot is then printed to the user interface.\n\nThe `output$data_table` object is created with `DT::renderDataTable()`, which takes the reactive variable `data()` and returns a table to the user interface using the `DT::datatable(`) function.\n\nFinally, the `output$download_data` object is created using `downloadHandler()`, which creates a download button for the user to download a .csv file of the data. The filename argument specifies the name of the file, and the content argument writes the data to a .csv file.\n\nHere is the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define server\nserver <- function(input, output) {\n  \n  # Create reactive data\n  data <- reactive({\n    # Call selected function with user input or tidy_empirical if user entered data\n    if (input$data_input_type == \"Enter Data\") {\n      data <- input$data\n      if (is.null(data) || data == \"\") {\n        return(NULL)\n      }\n      data <- as.numeric(strsplit(data, \",\")[[1]])\n      tidy_empirical(data)\n    } else {\n      match.fun(input$functions)(.num_sims = input$num_sims, .n = input$n)\n    }\n  })\n  \n  # Create density plot\n  output$density_plot <- renderPlot({\n    # Call autoplot on reactive data\n    if (!is.null(data())) {\n      p <- data() |>\n        tidy_autoplot(.plot_type = input$plot_type)\n      \n      print(p)\n    }\n  })\n  \n  # Create data table\n  output$data_table <- DT::renderDataTable({\n    # Return reactive data as a data table\n    if (!is.null(data())) {\n      DT::datatable(data())\n    }\n  })\n  \n  # Download data handler\n  output$download_data <- downloadHandler(\n    filename = function() {\n      if (input$data_input_type == \"Enter Data\") {\n        paste0(\"tidy_empirical.csv\")\n      } else {\n        paste0(input$functions, \".csv\")\n      }\n    },\n    content = function(file) {\n      write.csv(data(), file, row.names = FALSE)\n    }\n  )\n  \n}\n```\n:::\n\n\n# Data Table\n\nThe data table is a table that shows the data generated from the probability distribution. It's displayed on.\n\nOverall, this app is designed to allow users to generate various types of probability density plots and accompanying data tables based on user input. By allowing users to select different functions, sample sizes, and plot types, this app provides a flexible and customizable tool for exploring and visualizing probability distributions.\n\n# Full Shiny App\n\nHere is the full script:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(TidyDensity)\nlibrary(tidyverse)\nlibrary(DT)\n\n# Define UI\nui <- fluidPage(\n  titlePanel(\"TidyDensity App\"),\n  sidebarLayout(\n    sidebarPanel(\n      radioButtons(inputId = \"data_input_type\",\n                   label = \"Data Input Type:\",\n                   choices = c(\"Select Function\", \"Enter Data\"),\n                   selected = \"Select Function\"),\n      conditionalPanel(\n        condition = \"input.data_input_type == 'Enter Data'\",\n        textInput(inputId = \"data\",\n                  label = \"Enter data as a comma-separated list of numeric values\")\n      ),\n      conditionalPanel(\n        condition = \"input.data_input_type == 'Select Function'\",\n        selectInput(inputId = \"functions\",\n                    label = \"Select Function\",\n                    choices = c(\n                      \"tidy_normal\", \n                      \"tidy_bernoulli\", \n                      \"tidy_beta\", \n                      \"tidy_gamma\"\n                    )\n        )\n      ),\n      numericInput(inputId = \"num_sims\",\n                   label = \"Number of simulations:\",\n                   value = 1,\n                   min = 1,\n                   max = 15),\n      numericInput(inputId = \"n\",\n                   label = \"Sample size:\",\n                   value = 50,\n                   min = 30,\n                   max = 200),\n      selectInput(inputId = \"plot_type\",\n                  label = \"Select plot type\",\n                  choices = c(\n                    \"density\",\n                    \"quantile\",\n                    \"probability\",\n                    \"qq\",\n                    \"mcmc\"\n                  )\n      ),\n      downloadButton(outputId = \"download_data\", label = \"Download Data\")\n    ),\n    mainPanel(\n      plotOutput(\"density_plot\"),\n      DT::dataTableOutput(\"data_table\")\n    )\n  )\n)\n\n# Define server\nserver <- function(input, output) {\n  \n  # Create reactive data\n  data <- reactive({\n    # Call selected function with user input or tidy_empirical if user entered data\n    if (input$data_input_type == \"Enter Data\") {\n      data <- input$data\n      if (is.null(data) || data == \"\") {\n        return(NULL)\n      }\n      data <- as.numeric(strsplit(data, \",\")[[1]])\n      tidy_empirical(data)\n    } else {\n      match.fun(input$functions)(.num_sims = input$num_sims, .n = input$n)\n    }\n  })\n  \n  # Create density plot\n  output$density_plot <- renderPlot({\n    # Call autoplot on reactive data\n    if (!is.null(data())) {\n      p <- data() |>\n        tidy_autoplot(.plot_type = input$plot_type)\n      \n      print(p)\n    }\n  })\n  \n  # Create data table\n  output$data_table <- DT::renderDataTable({\n    # Return reactive data as a data table\n    if (!is.null(data())) {\n      DT::datatable(data())\n    }\n  })\n  \n  # Download data handler\n  output$download_data <- downloadHandler(\n    filename = function() {\n      if (input$data_input_type == \"Enter Data\") {\n        paste0(\"tidy_empirical.csv\")\n      } else {\n        paste0(input$functions, \".csv\")\n      }\n    },\n    content = function(file) {\n      write.csv(data(), file, row.names = FALSE)\n    }\n  )\n  \n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n```\n:::\n\n\nVoila!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}