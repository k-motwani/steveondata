{
  "hash": "a95191c09ac1f60e9f004b7fd5df1193",
  "result": {
    "markdown": "---\ntitle: \"Building models with {shiny} and {tidyAML} Part 2\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2023-04-26\"\ncategories: [rtip, shiny, tidymodels, tidyaml]\n---\n\n\n# Introduction\n\nYesterday I spoke about building `tidymodels` models using my package [`{tidyAML}`](https://www.spsanderson.com/tidyAML/) and `{shiny}`. I have made an update to it, and will continue to make updates to it this week.\n\nI have added all of the supported engines for __regression__ problems only, _NOT_ __classification__ yet, that will be tomorrow's work. I will then add a drop down for users to pick which backend function they want to use from `{parsnp}` like `linear_reg()`.\n\nHere are some pictures of the udpates.\n\n![New Drop Down Additions](1.PNG)\n\n![reactable Error, not sure on how to fix yet](2.PNG)\n\n![reactable output](3.PNG)\n\nHere is the full application, please steal this code and modify for yourself, you never know what you might come up with!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(tidyAML)\nlibrary(recipes)\nlibrary(DT)\nlibrary(glmnet)\nlibrary(tidymodels)\nlibrary(reactable)\n\ntidymodels_prefer()\n\nui <- fluidPage(\n  titlePanel(\"TidyAML Model Builder\"),\n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"file\", \"Upload your data file (csv or txt):\"),\n      selectInput(\"dataset\", \n                  \"Choose a built-in dataset:\", \n                  choices = c(\"mtcars\", \"iris\")\n                  ),\n      selectInput(\"predictor_col\", \n                  \"Select the predictor column:\", \n                  choices = NULL\n                  ),\n      selectInput(\"model_type\", \n                  \"Select a model type:\", \n                  choices = c(\"regression\", \"classification\")),\n      selectInput(\"model_fn\", \"Select a model function:\", \n                  choices = c(\"all\",\"lm\",\"brulee\",\"gee\",\"glm\",\n                              \"glmer\",\"glmnet\",\"gls\",\"lme\",\n                              \"lmer\",\"stan\",\"stan_glmer\",\n                              \"Cubist\",\"hurdle\",\"zeroinfl\",\"earth\",\n                              \"rpart\",\"dbarts\",\"xgboost\",\"lightgbm\",\n                              \"partykit\",\"mgcv\",\"nnet\",\"kknn\",\"ranger\",\n                              \"randomForest\",\"xrf\",\"LiblineaR\",\"kernlab\"\n                            )\n                  ),\n      actionButton(\"build_model\", \"Build Model\"),\n      verbatimTextOutput(\"recipe_output\")\n    ),\n    mainPanel(\n      verbatimTextOutput(\"model_table\"),\n      reactableOutput(\"model_reactable\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  \n  data <- reactive({\n    if (!is.null(input$file)) {\n      df <- read.csv(\n        input$file$datapath, \n        header = TRUE, \n        stringsAsFactors = FALSE\n        )\n      updateSelectInput(\n        session, \n        \"predictor_col\", \n        choices = names(df)\n        )\n      return(df)\n    } else if (!is.null(input$dataset)) {\n      df <- get(input$dataset)\n      updateSelectInput(\n        session, \n        \"predictor_col\", \n        choices = names(df)\n        )\n      return(df)\n    }\n  })\n  \n  recipe_obj <- eventReactive(input$predictor_col, {\n    rec <- recipe(as.formula(paste(input$predictor_col, \"~ .\")), \n                  data = data()\n                  ) |>\n      step_normalize(all_numeric(), -all_outcomes())\n    return(rec)\n  })\n  \n  model_fn <- reactive({\n    switch(input$model_fn,\n           \"all\" = \"all\",\n           \"lm\" = \"lm\",\n           \"brulee\" = \"brulee\",\n           \"gee\" = \"gee\",\n           \"glm\" = \"glm\",\n           \"glmer\" = \"glmer\",\n           \"glmnet\" = \"glmnet\",\n           \"gls\" = \"gls\",\n           \"lme\" = \"lme\",\n           \"lmer\" = \"lmer\",\n           \"stan\" = \"stan\",\n           \"stan_glmer\" = \"stan_glmer\",\n           \"Cubist\" = \"Cubist\",\n           \"hurdle\" = \"hurdle\",\n           \"zeroinfl\" = \"zeroinfl\",\n           \"earth\" = \"earth\",\n           \"rpart\" = \"rpart\",\n           \"dbarts\" = \"dbarts\",\n           \"xgboost\" = \"xgboost\"          ,\n           \"lightgbm\" = \"lightgbm\",\n           \"partykit\" = \"partykit\",\n           \"mgcv\" = \"mgcv\",\n           \"nnet\" = \"nnet\",\n           \"kknn\" = \"kknn\",\n           \"ranger\" = \"ranger\",\n           \"randomForest\" = \"randomForest\",\n           \"xrf\" = \"xrf\",\n           \"LiblineaR\" = \"LiblineaR\",\n           \"kernlab = kernlab\")\n  })\n  \n  model <- eventReactive(input$build_model, {\n    if (input$model_type == \"regression\") {\n      mod <- fast_regression(.data = data(),\n                             .rec_obj = recipe_obj(),\n                             .parsnip_eng = model_fn())\n    } else if (input$model_type == \"classification\") {\n      mod <- fast_classification(.data = data(),\n                                 .rec_obj = recipe_obj(),\n                                 .parsnip_eng = model_fn())\n    }\n    return(mod)\n  })\n  \n  output$recipe_output <- renderPrint({\n    if (!is.null(input$predictor_col)) {\n      summary(recipe_obj())\n    }\n  })\n  \n  output$model_table <- renderPrint({\n    if (input$build_model > 0) {\n      print(model())\n    }\n  })\n  \n  output$model_reactable <- renderReactable({\n    if (input$build_model > 0) {\n      reactable(model())\n    }\n  })\n  \n}\n\nshinyApp(ui = ui, server = server)\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}