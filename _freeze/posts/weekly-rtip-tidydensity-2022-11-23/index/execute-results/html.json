{
  "hash": "4e38baf3ea5783d9d751aef3a02ab0fa",
  "result": {
    "markdown": "---\ntitle: \"Summary Statistics with {TidyDensity}\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2022-11-23\"\ncategories: [code, weeklytip, tidydensity, datatable]\n---\n\n\n# Introduction\n\nMany times someone may want to see a summary or cumulative statistic for a given set of data or even from several simulations of data. I went over [bootstrap plotting](https://www.spsanderson.com/steveondata/posts/weekly-tip-tidydensity-2022-11-04/) earlier this month, and this is a form of what we will go over today although slightly more restrictive.\n\nI have decided to make today my [weekly r-tip](https://www.spsanderson.com/steveondata/#category=weeklytip) because tomorrow is Thanksgiving here in the US and I am taking an extended holiday so I won't be back until Monday.\n\nToday's function and weekly tip is on [`tidy_stat_tbl()`](https://www.spsanderson.com/TidyDensity/reference/tidy_stat_tbl.html). It is meant to be used with a `tidy_` distribution function. Let's take a look.\n\n# Function\n\nHere is the function call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  .data,\n  .x = y,\n  .fns,\n  .return_type = \"vector\",\n  .use_data_table = FALSE,\n  ...\n)\n```\n:::\n\n\nHere are the arguments to the parameters of the function:\n\n*  `.data` - The input data coming from a tidy_ distribution function.\n*  `.x` - The default is y but can be one of the other columns from the input `data.`\n*  `.fns` - The default is IQR, but this can be any stat function like quantile or median etc.\n*  `.return_type` - The default is \"vector\" which returns an sapply object.\n*  `.use_data_table` - The default is FALSE, TRUE will use data.table under the hood and still return a tibble. If this argument is set to TRUE then the .return_type parameter will be ignored.\n*  `...` - Addition function arguments to be supplied to the parameters of `.fns`\n\n# Examples\n\n## Single Simulation\n\nLet's go over some examples. Firstly, we will go over all the different `.return_type`'s of a single simulation of `tidy_normal()` using the `quantile` function.\n\n_Vector Output_ **BE CAREFUL IT USES SAPPLY**\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(TidyDensity)\n\nset.seed(123)\ntn <- tidy_normal()\n\ntidy_stat_tbl(\n  .data = tn,\n  .x = y,\n  .return_type = \"vector\",\n  .fns = quantile,\n  na.rm = TRUE,\n  probs = c(0.025, 0.5, 0.975)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      sim_number_1\n2.5%   -1.59190149\n50%    -0.07264039\n97.5%   1.77074730\n```\n:::\n:::\n\n\n_List Output with lapply_\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, quantile, \"list\", na.rm = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$sim_number_1\n         0%         25%         50%         75%        100% \n-1.96661716 -0.55931702 -0.07264039  0.69817699  2.16895597 \n```\n:::\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, quantile, \"list\", na.rm = TRUE, \n  probs = c(0.025, 0.5, 0.975)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$sim_number_1\n       2.5%         50%       97.5% \n-1.59190149 -0.07264039  1.77074730 \n```\n:::\n:::\n\n\n_Tibble output with tibble_\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, quantile, \"tibble\", na.rm = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  sim_number name  quantile\n  <fct>      <chr>    <dbl>\n1 1          0%     -1.97  \n2 1          25%    -0.559 \n3 1          50%    -0.0726\n4 1          75%     0.698 \n5 1          100%    2.17  \n```\n:::\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, quantile, \"tibble\", na.rm = TRUE, \n  probs = c(0.025, 0.5, 0.975)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  sim_number name  quantile\n  <fct>      <chr>    <dbl>\n1 1          2.5%   -1.59  \n2 1          50%    -0.0726\n3 1          97.5%   1.77  \n```\n:::\n:::\n\n\n_Tibble output with data.table_ The output object is a `tibble` but `data.table` is used to perform the calculations which can be magnitudes faster when simulations are large. I will showcase down the post.\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, quantile, .use_data_table = TRUE, na.rm = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  sim_number name  quantile\n  <fct>      <fct>    <dbl>\n1 1          0%     -1.97  \n2 1          25%    -0.559 \n3 1          50%    -0.0726\n4 1          75%     0.698 \n5 1          100%    2.17  \n```\n:::\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, quantile, .use_data_table = TRUE, na.rm = TRUE, \n  probs = c(0.025, 0.5, 0.975)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  sim_number name  quantile\n  <fct>      <fct>    <dbl>\n1 1          2.5%   -1.59  \n2 1          50%    -0.0726\n3 1          97.5%   1.77  \n```\n:::\n:::\n\n\nNow let's take a look with multiple simulations.\n\n## Multiple Simulations\n\nLet's set our simulation count to 5. While this is not a large amount it will serve as a good illustration on the outputs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nns <- 5\nf  <- quantile\nnr <- TRUE\np  <- c(0.025, 0.975)\n```\n:::\n\n\nOk let's run the same simulations but with the updated params.\n\n_Vector Output_ **BE CAREFUL IT USES SAPPLY**\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\ntn <- tidy_normal(.num_sims = ns)\n\ntidy_stat_tbl(\n  .data = tn,\n  .x = y,\n  .return_type = \"vector\",\n  .fns = f,\n  na.rm = nr,\n  probs = p\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      sim_number_1 sim_number_2 sim_number_3 sim_number_4 sim_number_5\n2.5%     -1.591901    -1.474945    -1.656679    -1.258156    -1.309749\n97.5%     1.770747     1.933653     1.894424     2.098923     1.943384\n```\n:::\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, .return_type = \"vector\",\n  .fns = f, na.rm = nr\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     sim_number_1 sim_number_2 sim_number_3 sim_number_4 sim_number_5\n0%    -1.96661716   -2.3091689   -2.0532472  -1.31080153   -1.3598407\n25%   -0.55931702   -0.3612969   -0.9505826  -0.49541417   -0.7140627\n50%   -0.07264039    0.1525789   -0.3048700  -0.07675993   -0.2240352\n75%    0.69817699    0.6294358    0.2900859   0.55145766    0.5287605\n100%   2.16895597    2.1873330    2.1001089   3.24103993    2.1988103\n```\n:::\n:::\n\n\n_List Output with lapply_\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, f, \"list\", na.rm = nr\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$sim_number_1\n         0%         25%         50%         75%        100% \n-1.96661716 -0.55931702 -0.07264039  0.69817699  2.16895597 \n\n$sim_number_2\n        0%        25%        50%        75%       100% \n-2.3091689 -0.3612969  0.1525789  0.6294358  2.1873330 \n\n$sim_number_3\n        0%        25%        50%        75%       100% \n-2.0532472 -0.9505826 -0.3048700  0.2900859  2.1001089 \n\n$sim_number_4\n         0%         25%         50%         75%        100% \n-1.31080153 -0.49541417 -0.07675993  0.55145766  3.24103993 \n\n$sim_number_5\n        0%        25%        50%        75%       100% \n-1.3598407 -0.7140627 -0.2240352  0.5287605  2.1988103 \n```\n:::\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, f, \"list\", na.rm = nr, \n  probs = p\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$sim_number_1\n     2.5%     97.5% \n-1.591901  1.770747 \n\n$sim_number_2\n     2.5%     97.5% \n-1.474945  1.933653 \n\n$sim_number_3\n     2.5%     97.5% \n-1.656679  1.894424 \n\n$sim_number_4\n     2.5%     97.5% \n-1.258156  2.098923 \n\n$sim_number_5\n     2.5%     97.5% \n-1.309749  1.943384 \n```\n:::\n:::\n\n\n_Tibble output with tibble_\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, f, \"tibble\", na.rm = nr\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 × 3\n   sim_number name        f\n   <fct>      <chr>   <dbl>\n 1 1          0%    -1.97  \n 2 1          25%   -0.559 \n 3 1          50%   -0.0726\n 4 1          75%    0.698 \n 5 1          100%   2.17  \n 6 2          0%    -2.31  \n 7 2          25%   -0.361 \n 8 2          50%    0.153 \n 9 2          75%    0.629 \n10 2          100%   2.19  \n# … with 15 more rows\n```\n:::\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, f, \"tibble\", na.rm = nr, \n  probs = p\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n   sim_number name      f\n   <fct>      <chr> <dbl>\n 1 1          2.5%  -1.59\n 2 1          97.5%  1.77\n 3 2          2.5%  -1.47\n 4 2          97.5%  1.93\n 5 3          2.5%  -1.66\n 6 3          97.5%  1.89\n 7 4          2.5%  -1.26\n 8 4          97.5%  2.10\n 9 5          2.5%  -1.31\n10 5          97.5%  1.94\n```\n:::\n:::\n\n\n_Tibble output with data.table_ The output object is a `tibble` but `data.table` is used to perform the calculations which can be magnitudes faster when simulations are large. I will showcase down the post.\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, f, .use_data_table = TRUE, na.rm = nr\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 × 3\n   sim_number name        f\n   <fct>      <fct>   <dbl>\n 1 1          0%    -1.97  \n 2 1          25%   -0.559 \n 3 1          50%   -0.0726\n 4 1          75%    0.698 \n 5 1          100%   2.17  \n 6 2          0%    -2.31  \n 7 2          25%   -0.361 \n 8 2          50%    0.153 \n 9 2          75%    0.629 \n10 2          100%   2.19  \n# … with 15 more rows\n```\n:::\n\n```{.r .cell-code}\ntidy_stat_tbl(\n  tn, y, f, .use_data_table = TRUE, na.rm = nr, \n  probs = p\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n   sim_number name      f\n   <fct>      <fct> <dbl>\n 1 1          2.5%  -1.59\n 2 1          97.5%  1.77\n 3 2          2.5%  -1.47\n 4 2          97.5%  1.93\n 5 3          2.5%  -1.66\n 6 3          97.5%  1.89\n 7 4          2.5%  -1.26\n 8 4          97.5%  2.10\n 9 5          2.5%  -1.31\n10 5          97.5%  1.94\n```\n:::\n:::\n\n\nOk, now that we have shown that, let's ratchet up the simulations so we can see the true difference in using the `.use_data_tbl` parameter when simulations are large. We are going to use `{rbenchmark}` for \n\n## Benchmarking\n\nHere we go. We are going to make a `tidy_bootstrap()` of the `mtcars$mpg` data which will produce 2000 simulations, we will replicate this 25 times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rbenchmark)\nlibrary(TidyDensity)\nlibrary(dplyr)\n\n# Get the interesting vector, well for this anyways\nx <- mtcars$mpg\n\n# Bootstrap the vector (2k simulations is default)\ntb <- tidy_bootstrap(x) %>%\n  bootstrap_unnest_tbl()\n\nbenchmark(\n  \"tibble\" = {\n    tidy_stat_tbl(tb, y, IQR, \"tibble\")\n  },\n  \"data.table\" = {\n    tidy_stat_tbl(tb, y, IQR, .use_data_table = TRUE, type = 7)\n  },\n  \"sapply\" = {\n    tidy_stat_tbl(tb, y, IQR, \"vector\")\n  },\n  \"lapply\" = {\n    tidy_stat_tbl(tb, y, IQR, \"list\")\n  },\n  replications = 25,\n  columns = c(\"test\",\"replications\",\"elapsed\",\"relative\",\"user.self\",\"sys.self\"  )\n) %>%\n  arrange(relative)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        test replications elapsed relative user.self sys.self\n1 data.table           25    4.11    1.000      3.33     0.11\n2     lapply           25   24.14    5.873     20.02     0.38\n3     sapply           25   25.11    6.109     21.01     0.28\n4     tibble           25   33.18    8.073     27.45     0.51\n```\n:::\n:::\n\n\nVoila!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}